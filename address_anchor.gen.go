package axongo

// Code generated by go generate; DO NOT EDIT. Check gen/ directory instead.

import (
	"context"
	"io"

	"golang.org/x/crypto/blake2b"

	"github.com/axonfibre/fibre.go/ierrors"
	"github.com/axonfibre/fibre.go/lo"
	"github.com/axonfibre/fibre.go/serializer/v2"
	"github.com/axonfibre/fibre.go/serializer/v2/stream"
	"github.com/axonfibre/axon.go/v4/hexutil"
)

const (
	// AnchorAddressBytesLength is the length of an AnchorAddress.
	AnchorAddressBytesLength = blake2b.Size256
	// AnchorAddressSerializedBytesSize is the size of a serialized AnchorAddress with its type denoting byte.
	AnchorAddressSerializedBytesSize = serializer.SmallTypeDenotationByteSize + AnchorAddressBytesLength
)

// AnchorAddress defines an AnchorAddress.
// An AnchorAddress is the Blake2b-256 hash of the OutputID which created it.
type AnchorAddress [AnchorAddressBytesLength]byte

func (addr *AnchorAddress) Clone() Address {
	cpy := &AnchorAddress{}
	copy(cpy[:], addr[:])

	return cpy
}

func (addr *AnchorAddress) StorageScore(_ *StorageScoreStructure, _ StorageScoreFunc) StorageScore {
	return 0
}

func (addr *AnchorAddress) ID() []byte {
	return lo.PanicOnErr(CommonSerixAPI().Encode(context.TODO(), addr))
}

func (addr *AnchorAddress) Key() string {
	return string(addr.ID())
}

func (addr *AnchorAddress) ChainID() ChainID {
	return AnchorID(*addr)
}

func (addr *AnchorAddress) AnchorID() AnchorID {
	return AnchorID(*addr)
}

func (addr *AnchorAddress) Equal(other Address) bool {
	otherAddr, is := other.(*AnchorAddress)
	if !is {
		return false
	}

	return *addr == *otherAddr
}

func (addr *AnchorAddress) Type() AddressType {
	return AddressAnchor
}

func (addr *AnchorAddress) Bech32(hrp NetworkPrefix) string {
	return bech32StringBytes(hrp, addr.ID())
}

func (addr *AnchorAddress) String() string {
	return hexutil.EncodeHex(addr.ID())
}

func (addr *AnchorAddress) Size() int {
	return AnchorAddressSerializedBytesSize
}

// AnchorAddressFromOutputID returns the AnchorAddress computed from a given OutputID.
func AnchorAddressFromOutputID(outputID OutputID) *AnchorAddress {
	address := blake2b.Sum256(outputID[:])

	return (*AnchorAddress)(&address)
}

// AnchorAddressFromReader parses the AnchorAddress from the given reader.
func AnchorAddressFromReader(reader io.Reader) (*AnchorAddress, error) {
	addrBytes, err := stream.ReadBytes(reader, AnchorAddressSerializedBytesSize)
	if err != nil {
		return nil, ierrors.Wrap(err, "unable to read address bytes")
	}

	addr, _, err := AddressFromBytes(addrBytes)
	if err != nil {
		return nil, ierrors.Wrap(err, "unable to parse address from bytes")
	}

	address, ok := addr.(*AnchorAddress)
	if !ok {
		return nil, ierrors.Errorf("invalid address type: %T", addr)
	}

	return address, nil
}
