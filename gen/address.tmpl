package iotago

// Code generated by go generate; DO NOT EDIT. Check gen/ directory instead.

import (
	"context"
	"io"
	{{if index .Features "frompubkey"}} "crypto/ed25519" {{end}}
    
	"golang.org/x/crypto/blake2b"

    "github.com/iotaledger/hive.go/ierrors"
	"github.com/iotaledger/hive.go/lo"
	"github.com/iotaledger/hive.go/serializer/v2"
	"github.com/iotaledger/hive.go/serializer/v2/stream"
	"github.com/iotaledger/iota.go/v4/hexutil"
)

const (
	// {{.Name}}BytesLength is the length of an {{.Name}}.
	{{.Name}}BytesLength = blake2b.Size256
	// {{.Name}}SerializedBytesSize is the size of a serialized {{.Name}} with its type denoting byte.
	{{.Name}}SerializedBytesSize = serializer.SmallTypeDenotationByteSize + {{.Name}}BytesLength
)

// {{.Name}} defines an {{.Name}}.
// An {{.Name}} {{.Description}}.
type {{.Name}} [{{.Name}}BytesLength]byte

func ({{.Receiver}} *{{.Name}}) Clone() Address {
	cpy := &{{.Name}}{}
	copy(cpy[:], {{.Receiver}}[:])

	return cpy
}

{{if not (index .Features "storagescore")}}
func ({{.Receiver}} *{{.Name}}) StorageScore(_ *StorageScoreStructure, _ StorageScoreFunc) StorageScore {
	return 0
}{{end}}

func ({{.Receiver}} *{{.Name}}) ID() []byte {
	return lo.PanicOnErr(CommonSerixAPI().Encode(context.TODO(), {{.Receiver}}))
}

func ({{.Receiver}} *{{.Name}}) Key() string {
	return string({{.Receiver}}.ID())
}

{{if index .Features "ed25519unlock"}}
func ({{.Receiver}} *{{.Name}}) Unlock(msg []byte, sig Signature) error {
	edSig, isEdSig := sig.(*Ed25519Signature)
	if !isEdSig {
		return ierrors.Wrapf(ErrSignatureAndAddrIncompatible, "can not unlock {{.Name}} with signature of type %s", sig.Type())
	}

	return edSig.Valid(msg, (*Ed25519Address)({{.Receiver}}))
}{{end}}

{{if index .Features "chainid"}}
func ({{.Receiver}} *{{.Name}}) ChainID() ChainID {
	return {{.IdentifierType}}(*{{.Receiver}})
}

func ({{.Receiver}} *{{.Name}}) {{.IdentifierType}}() {{.IdentifierType}} {
	return {{.IdentifierType}}(*{{.Receiver}})
}{{end}}

func ({{.Receiver}} *{{.Name}}) Equal(other Address) bool {
	otherAddr, is := other.(*{{.Name}})
	if !is {
		return false
	}

	return *{{.Receiver}} == *otherAddr
}

func ({{.Receiver}} *{{.Name}}) Type() AddressType {
	return {{.AddressType}}
}

func ({{.Receiver}} *{{.Name}}) Bech32(hrp NetworkPrefix) string {
	return bech32StringBytes(hrp, {{.Receiver}}.ID())
}

func ({{.Receiver}} *{{.Name}}) String() string {
	return hexutil.EncodeHex({{.Receiver}}.ID())
}

func ({{.Receiver}} *{{.Name}}) Size() int {
	return {{.Name}}SerializedBytesSize
}

{{if index .Features "frompubkey"}}
// {{.Name}}FromPubKey returns the address belonging to the given Ed25519 public key.
func {{.Name}}FromPubKey(pubKey ed25519.PublicKey) *{{.Name}} {
	address := blake2b.Sum256(pubKey[:])

	return (*{{.Name}})(&address)
}{{end}}

{{if index .Features "chainid"}}
// {{.Name}}FromOutputID returns the {{.Name}} computed from a given OutputID.
func {{.Name}}FromOutputID(outputID OutputID) *{{.Name}} {
	address := blake2b.Sum256(outputID[:])

	return (*{{.Name}})(&address)
}{{end}}

// {{.Name}}FromReader parses the {{.Name}} from the given reader.
func {{.Name}}FromReader(reader io.Reader) (*{{.Name}}, error) {
	addrBytes, err := stream.ReadBytes(reader, {{.Name}}SerializedBytesSize)
	if err != nil {
		return nil, ierrors.Wrap(err, "unable to read address bytes")
	}

	{{.Receiver}}, _, err := AddressFromBytes(addrBytes)
	if err != nil {
		return nil, ierrors.Wrap(err, "unable to parse address from bytes")
	}

	address, ok := {{.Receiver}}.(*{{.Name}})
	if !ok {
		return nil, ierrors.Errorf("invalid address type: %T", {{.Receiver}})
	}
	
	return address, nil
}
