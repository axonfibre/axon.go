package iotago

// Code generated by go generate; DO NOT EDIT. Check gen/ directory instead.

import (
	"encoding/hex"
	"sync"

	"golang.org/x/crypto/blake2b"

	"github.com/iotaledger/hive.go/ierrors"
	"github.com/iotaledger/iota.go/v4/hexutil"
)

const (
	// AnchorIDLength defines the length of an AnchorID.
	AnchorIDLength = blake2b.Size256
)

var (
	EmptyAnchorID = AnchorID{}
)

// AnchorID is a 32 byte hash value.
type AnchorID [AnchorIDLength]byte

type AnchorIDs []AnchorID

// AnchorIDFromData returns a new AnchorID for the given data by hashing it with blake2b.
func AnchorIDFromData(data []byte) AnchorID {
	return blake2b.Sum256(data)
}

// AnchorIDFromHexString converts the hex to an AnchorID representation.
func AnchorIDFromHexString(hex string) (AnchorID, error) {
	bytes, err := hexutil.DecodeHex(hex)
	if err != nil {
		return EmptyAnchorID, err
	}

	a, _, err := AnchorIDFromBytes(bytes)

	return a, err
}

// MustAnchorIDFromHexString converts the hex to an AnchorID representation.
func MustAnchorIDFromHexString(hex string) AnchorID {
	a, err := AnchorIDFromHexString(hex)
	if err != nil {
		panic(err)
	}

	return a
}

// IsValidAnchorID returns an error if the passed bytes are not a valid AnchorID, otherwise nil.
func IsValidAnchorID(b []byte) error {
	if len(b) != AnchorIDLength {
		return ierrors.Errorf("invalid AnchorID length: expected %d bytes, got %d bytes", AnchorIDLength, len(b))
	}

	return nil
}

func AnchorIDFromBytes(bytes []byte) (AnchorID, int, error) {
	var a AnchorID
	if err := IsValidAnchorID(bytes); err != nil {
		return a, 0, err
	}
	copy(a[:], bytes)

	return a, len(bytes), nil
}

func (a AnchorID) Bytes() ([]byte, error) {
	return a[:], nil
}

func (a AnchorID) MarshalText() (text []byte, err error) {
	dst := make([]byte, hex.EncodedLen(len(EmptyAnchorID)))
	hex.Encode(dst, a[:])

	return dst, nil
}

func (a *AnchorID) UnmarshalText(text []byte) error {
	_, err := hex.Decode(a[:], text)

	return err
}

// Empty tells whether the AnchorID is empty.
func (a AnchorID) Empty() bool {
	return a == EmptyAnchorID
}

// ToHex converts the AnchorID to its hex representation.
func (a AnchorID) ToHex() string {
	return hexutil.EncodeHex(a[:])
}

func (a AnchorID) String() string {
	return a.Alias()
}

var (
	// anchorIDAliases contains a dictionary of AnchorIDs associated to their human-readable alias.
	anchorIDAliases = make(map[AnchorID]string)

	// anchorIDAliasesMutex is the mutex that is used to synchronize access to the previous map.
	anchorIDAliasesMutex = sync.RWMutex{}
)

// RegisterAlias allows to register a human-readable alias for the AnchorID which will be used as a replacement for
// the String method.
func (a AnchorID) RegisterAlias(alias string) {
	anchorIDAliasesMutex.Lock()
	defer anchorIDAliasesMutex.Unlock()

	anchorIDAliases[a] = alias
}

// Alias returns the human-readable alias of the AnchorID (or the hex encoded bytes if no alias was set).
func (a AnchorID) Alias() (alias string) {
	anchorIDAliasesMutex.RLock()
	defer anchorIDAliasesMutex.RUnlock()

	if existingAlias, exists := anchorIDAliases[a]; exists {
		return existingAlias
	}

	return a.ToHex()
}

// UnregisterAlias allows to unregister a previously registered alias.
func (a AnchorID) UnregisterAlias() {
	anchorIDAliasesMutex.Lock()
	defer anchorIDAliasesMutex.Unlock()

	delete(anchorIDAliases, a)
}

// UnregisterAnchorIDAliases allows to unregister all previously registered aliases.
func UnregisterAnchorIDAliases() {
	anchorIDAliasesMutex.Lock()
	defer anchorIDAliasesMutex.Unlock()

	anchorIDAliases = make(map[AnchorID]string)
}

// Matches checks whether other matches this ChainID.
func (a AnchorID) Matches(other ChainID) bool {
	otherAnchorID, isAnchorID := other.(AnchorID)
	if !isAnchorID {
		return false
	}

	return a == otherAnchorID
}

// Addressable tells whether this ChainID can be converted into a ChainAddress.
func (a AnchorID) Addressable() bool {
	return true
}

// ToAddress converts this ChainID into an ChainAddress.
func (a AnchorID) ToAddress() ChainAddress {
	var addr AnchorAddress
	copy(addr[:], a[:])

	return &addr
}

// FromOutputID returns the ChainID computed from a given OutputID.
func (a AnchorID) FromOutputID(in OutputID) ChainID {
	return AnchorIDFromOutputID(in)
}

// AnchorIDFromOutputID returns the AnchorID computed from a given OutputID.
func AnchorIDFromOutputID(outputID OutputID) AnchorID {
	return blake2b.Sum256(outputID[:])
}
