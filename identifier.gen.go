package iotago

// Code generated by go generate; DO NOT EDIT. Check gen/ directory instead.

import (
	"encoding/hex"
	"sync"

	"golang.org/x/crypto/blake2b"

	"github.com/iotaledger/hive.go/ierrors"
	"github.com/iotaledger/iota.go/v4/hexutil"
)

const (
	// IdentifierLength defines the length of an Identifier.
	IdentifierLength = blake2b.Size256
)

var (
	EmptyIdentifier = Identifier{}
)

// Identifier is a 32 byte hash value.
type Identifier [IdentifierLength]byte

type Identifiers []Identifier

// IdentifierFromData returns a new Identifier for the given data by hashing it with blake2b.
func IdentifierFromData(data []byte) Identifier {
	return blake2b.Sum256(data)
}

// IdentifierFromHexString converts the hex to an Identifier representation.
func IdentifierFromHexString(hex string) (Identifier, error) {
	bytes, err := hexutil.DecodeHex(hex)
	if err != nil {
		return EmptyIdentifier, err
	}

	i, _, err := IdentifierFromBytes(bytes)

	return i, err
}

// MustIdentifierFromHexString converts the hex to an Identifier representation.
func MustIdentifierFromHexString(hex string) Identifier {
	i, err := IdentifierFromHexString(hex)
	if err != nil {
		panic(err)
	}

	return i
}

// IsValidIdentifier returns an error if the passed bytes are not a valid Identifier, otherwise nil.
func IsValidIdentifier(b []byte) error {
	if len(b) != IdentifierLength {
		return ierrors.Errorf("invalid Identifier length: expected %d bytes, got %d bytes", IdentifierLength, len(b))
	}

	return nil
}

func IdentifierFromBytes(bytes []byte) (Identifier, int, error) {
	var i Identifier
	if err := IsValidIdentifier(bytes); err != nil {
		return i, 0, err
	}
	copy(i[:], bytes)

	return i, len(bytes), nil
}

func (i Identifier) Bytes() ([]byte, error) {
	return i[:], nil
}

func (i Identifier) MarshalText() (text []byte, err error) {
	dst := make([]byte, hex.EncodedLen(len(EmptyIdentifier)))
	hex.Encode(dst, i[:])

	return dst, nil
}

func (i *Identifier) UnmarshalText(text []byte) error {
	_, err := hex.Decode(i[:], text)

	return err
}

// Empty tells whether the Identifier is empty.
func (i Identifier) Empty() bool {
	return i == EmptyIdentifier
}

// ToHex converts the Identifier to its hex representation.
func (i Identifier) ToHex() string {
	return hexutil.EncodeHex(i[:])
}

func (i Identifier) String() string {
	return i.Alias()
}

var (
	// identifierAliases contains a dictionary of Identifiers associated to their human-readable alias.
	identifierAliases = make(map[Identifier]string)

	// identifierAliasesMutex is the mutex that is used to synchronize access to the previous map.
	identifierAliasesMutex = sync.RWMutex{}
)

// RegisterAlias allows to register a human-readable alias for the Identifier which will be used as a replacement for
// the String method.
func (i Identifier) RegisterAlias(alias string) {
	identifierAliasesMutex.Lock()
	defer identifierAliasesMutex.Unlock()

	identifierAliases[i] = alias
}

// Alias returns the human-readable alias of the Identifier (or the hex encoded bytes if no alias was set).
func (i Identifier) Alias() (alias string) {
	identifierAliasesMutex.RLock()
	defer identifierAliasesMutex.RUnlock()

	if existingAlias, exists := identifierAliases[i]; exists {
		return existingAlias
	}

	return i.ToHex()
}

// UnregisterAlias allows to unregister a previously registered alias.
func (i Identifier) UnregisterAlias() {
	identifierAliasesMutex.Lock()
	defer identifierAliasesMutex.Unlock()

	delete(identifierAliases, i)
}

// UnregisterIdentifierAliases allows to unregister all previously registered aliases.
func UnregisterIdentifierAliases() {
	identifierAliasesMutex.Lock()
	defer identifierAliasesMutex.Unlock()

	identifierAliases = make(map[Identifier]string)
}
